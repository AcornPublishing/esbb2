/*
*********************************************************************************************************
*                                          PC SUPPORT FUNCTIONS
*
*                        (c) Copyright 1992-1998, Jean J. Labrosse, Plantation, FL
*                                           All Rights Reserved
*
* File : PC.C
* By   : Jean J. Labrosse
* Translated by : Won-Ho, Sung
*********************************************************************************************************
*/

#include "includes.h"

/*
*********************************************************************************************************
*                                                 상수
*********************************************************************************************************
*/
#define  DISP_BASE                  0xB800       /* 디스플레이 기준 세그먼트(0xB800=VGA, 0xB000=Mono)  */
#define  DISP_MAX_X                     80       /* 최대 열 수                                         */
#define  DISP_MAX_Y                     25       /* 최대 행 수                                         */

#define  TICK_T0_8254_CWR             0x43       /* 8254 PIT 컨트롤 워드 레지스터 어드레스.            */
#define  TICK_T0_8254_CTR0            0x40       /* 8254 PIT 타이머 0 레지스터 어드레스.               */
#define  TICK_T0_8254_CTR1            0x41       /* 8254 PIT 타이머 1 레지스터 어드레스.               */
#define  TICK_T0_8254_CTR2            0x42       /* 8254 PIT 타이머 2 레지스터 어드레스.               */

#define  TICK_T0_8254_CTR0_MODE3      0x36       /* 8254 PIT 카운터 0을 이진모드 3으로 설정.           */
#define  TICK_T0_8254_CTR2_MODE0      0xB0       /* 8254 PIT 카운터 2를 이진모드 0으로 설정.           */
#define  TICK_T0_8254_CTR2_LATCH      0x80       /* 8254 PIT 래치 명령 컨트롤 워드.                    */

#define  VECT_TICK                    0x08       /* 82C54 타이머 틱의 벡터 번호                        */
#define  VECT_DOS_CHAIN               0x81       /* DOS와의 연결을 위한 벡터 번호                      */

/*
*********************************************************************************************************
*                                          지역적 전역 변수
*********************************************************************************************************
*/
             
static INT16U    PC_ElapsedOverhead;
static jmp_buf   PC_JumpBuf;
static BOOLEAN   PC_ExitFlag;
void           (*PC_TickISR)(void);

/*$PAGE*/
/*
*********************************************************************************************************
*                                   'X', 'Y' 좌표에 한 문자 표시
*
* 설명        : 이 함수는 PC 화면 임의의 위치에 한 문자를 표시한다. 속도 향상을 위해 BIOS 서비스를 
*               사용하지 않고 비디오 메모리에 데이터를 직접 쓴다. 비디오 어댑터는 VGA호환으로 가정한다.
*               비디오 메모리는 절대 번지 0x000B8000부터 시작한다.
*               화면상의 각 문자는 두 바이트로 구성된다. 첫 번째 바이트는 화면상에 표시될 ASCII 문자이고
*               두 번째는 속성 바이트다. 예들 들어 속성 바이트의 값이 0x07인 경우 검정 바탕에 횐색
*               문자를 표시한다.
*
* 전달인자    : x      화면상의 열 위치를 지정한다. 이 값의 범위는 0에서 79까지다.
*                      0은 가장 왼쪽 열을 의미한다.
*               y      화면상의 행 위치를 지정한다. 이 값의 범위는 0에서 24까지다.
*                      0은 가장 윗쪽의 열을 의미한다.
*               c      표시하고자 하는 ASCII 문자. 128 이상의 값을 지정할 수도 있다.
*                      이 경우, 그래픽 기반의 특수문자가 표시된다.
*
*               color  전경/배경색을 지정하며 표시 문자를 점멸할 것인지를 결정한다.
*                      (가능한 색조합은 PC.H 참조)
*
* 리턴값      : 없음
*********************************************************************************************************
*/
void PC_DispChar (INT8U x, INT8U y, INT8U c, INT8U color)
{
    INT8U  far *pscr;
    INT16U      offset;


    offset  = (INT16U)y * DISP_MAX_X * 2 + (INT16U)x * 2;  /* 화면상의 위치를 계산한다                 */
    pscr    = (INT8U far *)MK_FP(DISP_BASE, offset);
    *pscr++ = c;                                           /* 비디오 RAM에 문자를 써 넣는다            */
    *pscr   = color;                                       /* 비디오 RAM에 속성 바이트를 써 넣는다     */
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                               열 지움
*
* 설명        : 이 함수는 BIOS를 사용하지 않고 비디오 RAM을 직접 액세스해서 80개의 열 중 하나를 지운다.
*               비디오 어댑터는 VGA호환으로 가정한다. 비디오 메모리는 절대 번지 0x000B8000부터 시작한다.
*               화면상의 각 문자는 두 바이트로 구성된다. 첫 번째 바이트는 화면상에 표시될 ASCII 문자이고
*               두 번째는 속성 바이트다. 예들 들어 속성 바이트의 값이 0x07인 경우 검정 바탕에 횐색
*               문자를 표시한다.
*
* 전달인자    : x      지우고자 하는 열을 지정하며 이 값의 범위는 0에서 79까지다.
*                      0은 가장 왼쪽 열을 의미한다.
*
*               color  전경/배경색을 지정한다.
*                      (가능한 색조합은 PC.H 참조)
*
* 리턴값      : 없음
*********************************************************************************************************
*/
void PC_DispClrCol (INT8U x, INT8U color)
{
    INT8U far *pscr;
    INT8U      i;


    pscr = (INT8U far *)MK_FP(DISP_BASE, (INT16U)x * 2);
    for (i = 0; i < DISP_MAX_Y; i++) {
        *pscr++ = ' ';                           /* 비디오 RAM에 공백문자를 써 넣는다                  */
        *pscr   = color;                         /* 비디오 RAM에 속성 바이트를 써 넣는다               */
        pscr    = pscr + DISP_MAX_X * 2;         /* 다음 열로 이동한다                                 */
    }
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                               행 지움
*
* 설명        : 이 함수는 BIOS를 사용하지 않고 비디오 RAM을 직접 액세스해서 25개의 행 중 하나를 지운다.
*               비디오 어댑터는 VGA호환으로 가정한다. 비디오 메모리는 절대 번지 0x000B8000부터 시작한다.
*               화면상의 각 문자는 두 바이트로 구성된다. 첫 번째 바이트는 화면상에 표시될 ASCII 문자이고
*               두 번째는 속성 바이트다. 예들 들어 속성 바이트의 값이 0x07인 경우 검정 바탕에 횐색
*               문자를 표시한다.
*
* 전달인자    : y      지우고자 하는 행을 지정하며 이 값의 범위는 0에서 24까지다.
*                      0은 가장 윗쪽 행을 의미한다.
*
*               color  전경/배경색을 지정한다.
*                      (가능한 색조합은 PC.H 참조)
*
* 리턴값      : 없음
*********************************************************************************************************
*/
void PC_DispClrRow (INT8U y, INT8U color)
{
    INT8U far *pscr;
    INT8U      i;


    pscr = (INT8U far *)MK_FP(DISP_BASE, (INT16U)y * DISP_MAX_X * 2);
    for (i = 0; i < DISP_MAX_X; i++) {
        *pscr++ = ' ';                           /* 비디오 RAM에 공백문자를 써 넣는다                  */
        *pscr++ = color;                         /* 비디오 RAM에 속성 바이트를 써 넣는다               */
    }
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                              화면 지움
*
* 설명        : 이 함수는 BIOS를 사용하지 않고 비디오 RAM을 직접 액세스해서 화면 전체를 지운다.
*               비디오 어댑터는 VGA호환으로 가정한다. 비디오 메모리는 절대 번지 0x000B8000부터 시작한다.
*               화면상의 각 문자는 두 바이트로 구성된다. 첫 번째 바이트는 화면상에 표시될 ASCII 문자이고
*               두 번째는 속성 바이트다. 예들 들어 속성 바이트의 값이 0x07인 경우 검정 바탕에 횐색
*               문자를 표시한다.
*
*               color  전경/배경색을 지정한다.
*                      (가능한 색조합은 PC.H 참조)
*
* 리턴값      : 없음
*********************************************************************************************************
*/
void PC_DispClrScr (INT8U color)
{
    INT8U  far *pscr;
    INT16U      i;


    pscr = (INT8U far *)MK_FP(DISP_BASE, 0x0000);
    for (i = 0; i < (DISP_MAX_X * DISP_MAX_Y); i++) { /* PC 화면은 80열과 25행으로 구성됨              */
        *pscr++ = ' ';                                /* 비디오 RAM에 공백문자를 써 넣는다             */
        *pscr++ = color;                              /* 비디오 RAM에 속성 바이트를 써 넣는다          */
    }
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                    'X', 'Y' 좌표에 문자열 표시
*
* 설명        : 이 함수는 PC 화면 임의의 위치에 문자열을 표시한다. 속도 향상을 위해 BIOS 서비스를 
*               사용하지 않고 비디오 메모리에 데이터를 직접 쓴다. 비디오 어댑터는 VGA호환으로 가정한다.
*               비디오 메모리는 절대 번지 0x000B8000부터 시작한다.
*               화면상의 각 문자는 두 바이트로 구성된다. 첫 번째 바이트는 화면상에 표시될 ASCII 문자이고
*               두 번째는 속성 바이트다. 예들 들어 속성 바이트의 값이 0x07인 경우 검정 바탕에 횐색
*               문자를 표시한다.
*
* 전달인자    : x      화면상의 열 위치를 지정한다. 이 값의 범위는 0에서 79까지다.
*                      0은 가장 왼쪽 열을 의미한다.
*               y      화면상의 행 위치를 지정한다. 이 값의 범위는 0에서 24까지다.
*                      0은 가장 윗쪽의 열을 의미한다.
*               c      표시하고자 하는 ASCII 문자열. 128 이상의 값을 가지는 문자열을 지정할 수도 있다.
*                      이 경우, 그래픽 기반의 특수문자가 표시된다.
*               color  전경/배경색을 지정하며 표시 문자를 점멸할 것인지를 결정한다.
*                      (가능한 색조합은 PC.H 참조)
*
* 리턴값      : 없음
*********************************************************************************************************
*/
void PC_DispStr (INT8U x, INT8U y, INT8U *s, INT8U color)
{
    INT8U  far *pscr;
    INT16U      offset;


    offset  = (INT16U)y * DISP_MAX_X * 2 + (INT16U)x * 2;   /*첫 번째 문자를 써 넣을 메모리 주소 계산  */
    pscr    = (INT8U far *)MK_FP(DISP_BASE, offset);
    while (*s) {
        *pscr++ = *s++;                                     /* 문자를 비디오 RAM에 써 넣는다           */
        *pscr++ = color;                                    /* 속성 바이트를 비디오 RAM에 써 넣는다    */
    }
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                             DOS로 복귀
*
* 설명        : 이 함수는 'PC_JumpBuf'에 저장된 위치로 점프해서 제어권을 DOS로 넘겨 준다.
*               점프할 위치는 'PC_DOSSaveReturn()'에 의해서 저장된다.
*               점프 명령이 실행된 후 프로그램은 'PC_DOSSaveReturn()'의 'set jump' 바로 다음 라인이
*               실행된다. 'PC_ExitFlag'를 TRUE로 설정함으로써 'PC_DOSSaveReturn()'의 'if' 구문 내의 
*               코드를 실행시킨다.
*
* 전달인자    : 없음
*
* 리턴값      : 없음
*********************************************************************************************************
*/
void PC_DOSReturn (void)
{
    PC_ExitFlag = TRUE;                                    /* DOS로 복귀함을 알린다                    */
    longjmp(PC_JumpBuf, 1);                                /* 저장된 환경으로 점프                     */
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                          DOS 복귀 위치 저장
*
* 설명        : 이 함수는 DOS로 복귀할 때를 대비해서 DOS 상에서 마지막으로 실행된 위치를 저장한다.
*               따라서 uC/OS-II 상에서의 멀티태스킹을 종료하고 아무일 없던 것 처럼 DOS로 돌아올 수 있다.
*               'main()' 함수는 이 함수를 호출해서 'PC_ExitFlag'를 FALSE로 설정한다. 따라서 'if' 구문
*               은 거짓이 되고 해당되는 구문을 실행하지 않는다. 그 대신 CPU 레지스터를 'PC_JumpBuf'에
*               저장하고 호출자로 리턴한다.  'PC_JumpBuf'를 이용해서 점프 명령을 수행하면
*               프로그램의 실행은 'if' 구문에서 재개되고 이 때 'PC_ExitFlag'는 TRUE로 설정되어 있으므로
*               'if' 구문이 실행되어 DOS환경을 복구한다.
*
*
* 전달인자    : 없음
*
* 리턴값      : 없음
*********************************************************************************************************
*/
void PC_DOSSaveReturn (void)
{
    PC_ExitFlag  = FALSE;                                  /* DOS로 복귀하지 않는다는 것을 알림!       */
    OSTickDOSCtr =     1;                                  /* DOS 틱 카운터 초기화                     */
    PC_TickISR   = PC_VectGet(VECT_TICK);                  /* MS-DOS 틱 벡터를 얻는다                  */
    
    OS_ENTER_CRITICAL();
    PC_VectSet(VECT_DOS_CHAIN, PC_TickISR);                /* MS-DOS 틱 ISR을 연결하기 위해서 저장     */
    OS_EXIT_CRITICAL();
    
    setjmp(PC_JumpBuf);                                    /* DOS상에서의 위치 저장                    */
    if (PC_ExitFlag == TRUE) {                             /* DOS로 복귀하는 것인가?                   */
        OS_ENTER_CRITICAL();
        PC_SetTickRate(18);                                /* 틱 주기를 18.2 Hz로 설정                 */
        PC_VectSet(VECT_TICK, PC_TickISR);                 /* DOS 틱 벡터를 복구                       */
        OS_EXIT_CRITICAL();
        PC_DispClrScr(DISP_FGND_WHITE + DISP_BGND_BLACK);  /* 화면을 지운다                            */
        exit(0);                                           /* DOS로 돌아간다                           */
    }
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                          시간 측정 초기화
*
* 설명        : 이 함수는 시작과 종료 함수의 실행시간을 측정함으로써 시간 측정 모듈을 초기화 한다.
*               즉, 시작과 종료 함수의 실행시간을 보상해서 모듈을 교정한다.
*
*
* 전달인자    : 없음.
*
* 리턴값      : 없음.
*********************************************************************************************************
*/
void PC_ElapsedInit(void)
{
    PC_ElapsedOverhead = 0;
    PC_ElapsedStart();
    PC_ElapsedOverhead = PC_ElapsedStop();
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                       PC 상의 타이머 #2 초기화
*
* 설명        : 이 함수는 PC의 타이머 #2를 두 개의 이벤트 사이의 시간을 측정할 수 있도록 초기화 한다.
*               함수가 복귀된 후에도 타이머 #2는 계속 돌아간다.
*
* 전달인자    : 없음.
*
* 리턴값      : 없음.
*********************************************************************************************************
*/
void PC_ElapsedStart(void)
{
    INT8U  data;


    OS_ENTER_CRITICAL();
    data  = (INT8U)inp(0x61);                              /* 타이머 #2 비활성화                       */
    data &= 0xFE;
    outp(0x61, data);
    outp(TICK_T0_8254_CWR,  TICK_T0_8254_CTR2_MODE0);      /* 타이머 #2를 모드 0으로 설정한다          */
    outp(TICK_T0_8254_CTR2, 0xFF);
    outp(TICK_T0_8254_CTR2, 0xFF);
    data |= 0x01;                                          /* 타이머를 시작한다                        */
    outp(0x61, data);
    OS_EXIT_CRITICAL();
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                 타이머 #2를 정지하고 경과 시간을 얻는다
*
* 설명        : 이 함수는 PC의 타이머 #2를 정지시킨 후 경과된 카운트를 읽어내어  그 값을 마이크로 초로
*               변환한다.
*
* 전달인자    : 없음.
*
* 리턴값      : 타이머가 마지막으로 시작된 때 부터의 마이크로 초 단위의 시간.
*
* 노트        : - 리턴된 시간은 시작 종료 함수의 실행시간을 의미한다.
*               - 54926은 54926S-16 또는 0.838097를 의미하며 카운트 값을 시간(마이크로 초)으로 변환
*                 하는데 사용된다. 타이머 #2 클럭 소스의 주파수는 1.19318 MHz(또는 0.838097 uS)다.
*********************************************************************************************************
*/
INT16U PC_ElapsedStop(void)
{
    INT8U   data;
    INT8U   low;
    INT8U   high;
    INT16U  cnts;


    OS_ENTER_CRITICAL();
    data  = (INT8U)inp(0x61);                                    /* 타이머 비활성화                    */
    data &= 0xFE;
    outp(0x61, data);
    outp(TICK_T0_8254_CWR, TICK_T0_8254_CTR2_LATCH);             /* 타이머 값을 고정해 둔다            */
    low  = inp(TICK_T0_8254_CTR2);
    high = inp(TICK_T0_8254_CTR2);
    cnts = (INT16U)0xFFFF - (((INT16U)high << 8) + (INT16U)low); /* 실행시간 계산                      */
    OS_EXIT_CRITICAL();
    return ((INT16U)((ULONG)cnts * 54926L >> 16) - PC_ElapsedOverhead);
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                         현재 날짜, 시간 얻기
*
* 설명        : 이 함수는 PC로부터 현재의 날짜와 시간을 알아낸다.
*
* 전달인자    : s    현재의 날짜와 시간에 대한 문자열이 저장될 영역을 가리키는 포인터.
*                    이 포인터가 가리키는 영역에는 NUL문자를 포함해서 최소한 21바이트가 확보되어야 한다.
*                    날짜와 시간은 다음과 같은 형식으로 저장된다:
*
*                        "YYYY-MM-DD  HH:MM:SS"
*
* 리턴값      : 없음
*********************************************************************************************************
*/
void PC_GetDateTime (char *s)
{
    struct time now;
    struct date today;


    gettime(&now);
    getdate(&today);
    sprintf(s, "%04d-%02d-%02d  %02d:%02d:%02d",
               today.da_year,
               today.da_mon,
               today.da_day,
               now.ti_hour,
               now.ti_min,
               now.ti_sec);
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                         키 체크와 키 값 읽기
*
* 설명        : 이 함수는 키가 눌린것을 확인하고 눌려있는 경우 상응하는 키 값을 리턴한다.
*               또 키가 눌린 경우는 읽힌 키 값은 전달인자가 가리키는 곳에 저장된다.
*
*
* 전달인자    : c     키 값이 저장될 위치를 가리키는 포인터.
*
* 리턴값      : TRUE  키가 눌렸음
*               FALSE 눌리지 않았음
*********************************************************************************************************
*/
BOOLEAN PC_GetKey (INT16S *c)
{
    if (kbhit()) {                                         /* 키가 눌렸는가?                           */
        *c = (INT16S)getch();                              /* 눌리 키의 값을 읽는다                    */
        return (TRUE);
    } else {
        *c = 0x00;                                         /* 키가 눌리지 않았음                       */
        return (FALSE);
    }
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                          PC의 틱 주기 설정
*
* 설명        : 이 함수는 PC의 틱 주기를 변경한다.
*
* 전달인자    : freq      원하는 틱커의 주파수(Hz)
*
* 리턴값      : 없음
*
* 노트        : 1) 2386360은 8254칩으로 항상 일정하게 입력되는 주파수인 1.193180 MHz의 두배다.
*
*               2) 방정식은 8254에 로드될 카운트 값을 계산한다. 정수 연산에서의 반올림 때문에 방정식을
*                  변칙적으로 사용한다. 실제로는 다음과 같은 부동소수 방정식이다.
*
*          
*                              1193180.0 Hz
*                      count = ------------ + 0.5
*                                  freq
*********************************************************************************************************
*/
void PC_SetTickRate (INT16U freq)
{
    INT16U  count;


    if (freq == 18) {                            /* DOS용 주파수를 복구할 필요가 있는가?               */
        count = 0;
    } else if (freq > 0) {                        
                                                 /* 원하는 주파수에 대한 8254 카운트 값을 계산해서...  */
                                                 /* ... 가장 가까운 정수값으로 반올림 한다             */
        count = (INT16U)(((INT32U)2386360L / freq + 1) >> 1); 
    } else {
        count = 0;
    }
    OS_ENTER_CRITICAL();
    outp(TICK_T0_8254_CWR,  TICK_T0_8254_CTR0_MODE3); /* 8254에 카운트 값을 로드한다                   */  
    outp(TICK_T0_8254_CTR0, count & 0xFF);            /* 하위 바이트                                   */
    outp(TICK_T0_8254_CTR0, (count >> 8) & 0xFF);     /* 상위 바이트                                   */
    OS_EXIT_CRITICAL();
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                           인터럽트 벡터 얻기
*
* 설명        : 이 함수는 지정된 벡터에 저장된 포인터를 읽는다.
*
* 전달인자    : vect  원하는 인터럽트 벡터 번호. 0에서 255사이의 값이다.
*
* 리턴값      : 지정된 벡터위치에 저장된 인터럽트 핸들러의 주소.
*********************************************************************************************************
*/
void *PC_VectGet (INT8U vect)
{
    INT16U    *pvect;
    INT16U     off;
    INT16U     seg;
    
    
    pvect = (INT16U *)MK_FP(0x0000, vect * 4);        /* 원하는 벡터 위치의 인터럽트 벡터 테이블 지정  */
    OS_ENTER_CRITICAL();
    off   = *pvect++;                                 /* 벡터의 오프셋을 얻는다                        */
    seg   = *pvect;                                   /* 벡터의 세그먼트를 얻는다                      */
    OS_EXIT_CRITICAL();
    return (MK_FP(seg, off));
}

/*
*********************************************************************************************************
*                                        인터럽트 벡터 설정
*
* 설명        : 이 함수는 인터럽트 벡터 테이블에 인터럽트 벡터를 설정한다.
*
* 전달인자    : vect  원하는 인터럽트 벡터 번호. 0에서 255사이의 값을 갖는다.
*               isr   인터럽트나 예외가 발생했을 때 실행하고자 하는 함수에 대한 포인터.
*
* 리턴값      : 없음
*********************************************************************************************************
*/
void PC_VectSet (INT8U vect, void (*isr)(void))
{
    INT16U  *pvect;
    
    
    pvect    = (INT16U *)MK_FP(0x0000, vect * 4);     /* 벡터번호에 해당 하는 테이블 상의 위치를 지시  */
    OS_ENTER_CRITICAL();
    *pvect++ = (INT16U)FP_OFF(isr);                   /* ISR의 오프셋 저장                             */
    *pvect   = (INT16U)FP_SEG(isr);                   /* ISR의 세그먼트 저장                           */
    OS_EXIT_CRITICAL();
}
