/*
*********************************************************************************************************
*                                  Embedded Systems Building Blocks
*                               Complete and Ready-to-Use Modules in C
*
*                                            Timer Manager
*
*                           (c) Copyright 1999, Jean J. Labrosse, Weston, FL
*                                          All Rights Reserved
*
* Filename   : TMR.C
* Programmer : Jean J. Labrosse
* Translated by : Won-Ho, Sung
*********************************************************************************************************
*/

/*
*********************************************************************************************************
*                                              인크루드 파일
*********************************************************************************************************
*/

#define  TMR_GLOBALS
#include "includes.h"

/*
*********************************************************************************************************
*                                                지역변수
*********************************************************************************************************
*/

static  OS_EVENT   *TmrSemTenths;
static  OS_STK      TmrTaskStk[TMR_TASK_STK_SIZE];
static  INT8U       TmrTickCtr;

/*
*********************************************************************************************************
*                                             지역함수 원형
*********************************************************************************************************
*/

static  void        TmrTask(void *data);

/*$PAGE*/
/*
*********************************************************************************************************
*                                         타이머 만료 함수 설정
*
* 설명      : 타이머가 만료될 때의 사용자 함수를 설정.
* 전달인자  : n         타이머 번호 0..TMR_MAX_TMR-1
*             fnct      타이머가 만료될 때 실행될 함수의 포인터.
*             arg       'fnct'로 전달되는 인자의 포인터.
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrCfgFnct (INT8U n, void (*fnct)(void *), void *arg)
{
    TMR *ptmr;


    if (n < TMR_MAX_TMR) {
        ptmr             = &TmrTbl[n];
        OS_ENTER_CRITICAL();
        ptmr->TmrFnct    = fnct;                 /* 타이머에 사용자 함수 포인터를 저장한다             */
        ptmr->TmrFnctArg = arg;                  /* 사용자 함수에 대한 전달인자의 포인터를 저장한다    */
        OS_EXIT_CRITICAL();
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                              타이머 점검
*
* 설명      : 이 함수는 타이머가 만료됐는지를 점검한다
* 전달인자  : n      점검하고자 하는 타이머 번호
* 리턴값    : 0      타이머가 만료됐을 경우
*             TmrCtr 타이머가 만료되기 전까지 남은 0.1초 단위의 시간
*********************************************************************************************************
*/

INT16U  TmrChk (INT8U n)
{
    INT16U val;


    val = 0;
    if (n < TMR_MAX_TMR) {
        OS_ENTER_CRITICAL();
        val = TmrTbl[n].TmrCtr;
        OS_EXIT_CRITICAL();
    }
    return (val);
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                         타이머를 문자열로 포맷
*
* 설명      : 타이머를 ASCII 문자열로 포맷한다.
* 전달인자  : n      원하는 타이머
*             s      문자열 포인터. 문자열은 다음과 같은 형식의 문자열을 저장 할 수 있는 충분한
*                    공간을 확보해야 한다.
*                    "MM:SS.T"
*********************************************************************************************************
*/

void  TmrFormat (INT8U n, char *s)
{
    INT8U   min;
    INT8U   sec;
    INT8U   tenths;
    INT16U  val;


    if (n < TMR_MAX_TMR) {
        OS_ENTER_CRITICAL();
        val    = TmrTbl[n].TmrCtr;                    /* 변환을 위해 타이머의 값을 복사한다            */
        OS_EXIT_CRITICAL();
        min    = (INT8U)(val / 600);
        sec    = (INT8U)((val - min * 600) / 10);
        tenths = (INT8U)(val % 10);
        s[0]   = min / 10 + '0';                      /* TIMER를 ASCII로 변환한다                      */
        s[1]   = min % 10 + '0';
        s[2]   = ':';
        s[3]   = sec / 10 + '0';
        s[4]   = sec % 10 + '0';
        s[5]   = '.';
        s[6]   = tenths   + '0';
        s[7]   = NUL;
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                          타이머 관리자 초기화
*
* 설명      : 이 함수는 타이머 관리자 모듈을 초기화 한다.
* 전달인자  : 없음
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrInit (void)
{
    INT8U  err;
    INT8U  i;
    TMR   *ptmr;


    ptmr = &TmrTbl[0];
    for (i = 0; i < TMR_MAX_TMR; i++) {          /* 모든 타이머를 리셋하고 비활성화한다                */
        ptmr->TmrEn   = FALSE;
        ptmr->TmrCtr  = 0;
        ptmr->TmrInit = 0;
        ptmr->TmrFnct = NULL;
        ptmr++;
    }
    TmrTickCtr   = 0;
    TmrSemTenths = OSSemCreate(0);               /* 0.1초를 신호하기 위한 카운팅 세마포어를 생성       */
    OSTaskCreate(TmrTask, (void *)0, &TmrTaskStk[TMR_TASK_STK_SIZE], TMR_TASK_PRIO);
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                              타이머 리셋
*
* 설명      : 이 함수는 타이머를 초기 상태로 리셋한다.
* 전달인자  : n         리셋하고자 하는 타이머
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrReset (INT8U n)
{
    TMR *ptmr;


    if (n < TMR_MAX_TMR) {
        ptmr         = &TmrTbl[n];
        OS_ENTER_CRITICAL();
        ptmr->TmrCtr = ptmr->TmrInit;       /* 카운터를 리로드 한다                                    */
        OS_EXIT_CRITICAL();
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                타이머 세트 (분, 초, 0.1초 단위로 지정함)
*
* 설명      : 타이머를 지정된 분, 초, 0.1초 단위로 설정한다.
*             함수는 분, 초, 0.1초의 값을 변환한다.
* 전달인자  : n         타이머 번호  0..TMR_MAX_TMR-1
*             min       분의 값
*             sec       초의 값
*             tenths    0.1초의 값
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrSetMST (INT8U n, INT8U min, INT8U sec, INT8U tenths)
{
    TMR   *ptmr;
    INT16U  val;


    if (n < TMR_MAX_TMR) {
        ptmr          = &TmrTbl[n];
        val           = (INT16U)min * 600 + (INT16U)sec * 10 + (INT16U)tenths;
        OS_ENTER_CRITICAL();
        ptmr->TmrInit = val;
        ptmr->TmrCtr  = val;
        OS_EXIT_CRITICAL();
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                   타이머 세트(0.1초 단위로 지정함)
*
* 설명      : 지정된 0.1초 단위로 타이머를 설정한다.
* 전달인자  : n         타이머 번호  0..TMR_MAX_TMR-1
*             tenths    타이머에 로드 될 0.1초의 값
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrSetT (INT8U n, INT16U tenths)
{
    TMR *ptmr;


    if (n < TMR_MAX_TMR) {
        ptmr          = &TmrTbl[n];
        OS_ENTER_CRITICAL();
        ptmr->TmrInit = tenths;
        ptmr->TmrCtr  = tenths;
        OS_EXIT_CRITICAL();
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                         '클럭 틱'이 발생했음을 타이머 관리자 모듈에게 알리기
*
* 설명      : 이 함수는 매 틱마다 '클럭 틱' ISR에 의해서 호출된다.  따라서 이 함수는 
*             0.1초 단위로 클럭 틱을 카운팅하는 일을 한다.  0.1초가 경과하면 이 함수는 타이머 관리자
*             태스크에게 신호를 보낸다.
* 전달인자  : 없음.
* 리턴값    : 없음.
* 노트      : TMR_DLY_TICKS는 0.1초 지연에 사용될 수 있도록 설정돼야 한다
*             여러 분이 uC/OS-II를 사용하고 있다면 이 값은 OS_TICKS_PER_SEC / 10 로 설정될 수 있다.
*********************************************************************************************************
*/

void  TmrSignalTmr (void)
{
    TmrTickCtr++;
    if (TmrTickCtr >= TMR_DLY_TICKS) {
        TmrTickCtr = 0;
        OSSemPost(TmrSemTenths);
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                              타이머 시작
*
* 설명      : 이 함수는 타이머를 시작 시킨다.
* 전달인자  : n         시작할 타이머 번호
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrStart (INT8U n)
{
    if (n < TMR_MAX_TMR) {
        OS_ENTER_CRITICAL();
        TmrTbl[n].TmrEn = TRUE;
        OS_EXIT_CRITICAL();
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                              타이머 정지
*
* 설명      : 이 함수는 타이머를 정지 시킨다
* 전달인자  : n         정지 시킬 타이머 번호
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrStop (INT8U n)
{
    if (n < TMR_MAX_TMR) {
        OS_ENTER_CRITICAL();
        TmrTbl[n].TmrEn = FALSE;
        OS_EXIT_CRITICAL();
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                          타이머 관리자 태스크
*
* 설명      : 이 함수는 TmrInit()에 의해서 호출되며 타이머를 갱신하는 일을 한다.
*             TmrTask() 0.1초마다 실행된다.
* 전달인자  : 없음.
* 리턴값    : 없음.
* 노트      : 1) 타이머가 종료될 때 실행되는 함수는 크리티컬 섹션 밖에서 실행된다.
*
*********************************************************************************************************
*/

static  void  TmrTask (void *data)
{
    TMR    *ptmr;
    INT8U   err;
    INT8U   i;
    void  (*pfnct)(void *);                           /* 타이머가 만료될 때 실행될 함수                */
    void   *parg;                                     /* 위의 함수로 전달되는 인자                     */
    


    data  = data;                                     /* 컴파일러 경고를 피한다 (uC/OS-II요구사항)     */
    pfnct = (void (*)(void *))0;                      /* 함수 포인터를 리셋한다                        */
    parg  = (void *)0;
    for (;;) {

#if TMR_USE_SEM
        OSSemPend(TmrSemTenths, 0, &err);             /* 클럭 틱 ISR로부터 0.1초 경과 신호를 받는다    */
#else
        OSTimeDlyHMSM(0, 0, 0, 100);                  /* 0.1초 지연                                    */
#endif

        ptmr = &TmrTbl[0];                            /* 타이머 테이블의 시작 주소로 포인트한다        */
        for (i = 0; i < TMR_MAX_TMR; i++) {
            OS_ENTER_CRITICAL();
            if (ptmr->TmrEn == TRUE) {                /* 타이머가 활성화됐을 경우만 카운터를 감소      */
                if (ptmr->TmrCtr > 0) {
                    ptmr->TmrCtr--;
                    if (ptmr->TmrCtr == 0) {               /* 타이머가 만료됐는지 확인                 */
                        ptmr->TmrEn = FALSE;               /* 예, 타이머 정지                          */
                        pfnct       = ptmr->TmrFnct;       /* 실행할 함수와 그 전달인자의...           */
                        parg        = ptmr->TmrFnctArg;    /* ... 포인터를 얻는다                      */
                    }
                }
            }
            OS_EXIT_CRITICAL();
            if (pfnct != (void (*)(void *))0) {       /* 타이머 만료 함수를 실행해야 하는지 점검한다   */
                (*pfnct)(parg);                       
                pfnct = (void (*)(void *))0;
            }
            ptmr++;
        }
    }
}
