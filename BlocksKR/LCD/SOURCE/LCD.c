/*
*********************************************************************************************************
*                                   Embedded Systems Building Blocks
*                                Complete and Ready-to-Use Modules in C
*
*                                        LCD Display Module Driver
*
*                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
*                                           All Rights Reserved
*
* Filename   : LCD.C
* Programmer : Jean J. Labrosse
* Translated by : Won-Ho, Sung
*********************************************************************************************************
*                                                 설명
*
*
* 이 모듈은 알파벳과 숫자를 디스플레이 할수 있는 모듈의 인터페이스를 제공한다
*
* 드라이버 현재 버전은 다음 칩을 기반으로 하는 모든 알파뉴메릭 LCD모듈을 지원한다:
*     히다찌 HD44780 도트 매트릭스 LCD 컨트롤러
*
* 이 드라이버는 다음과 같은 구성을 가지는 LCD 디스플레이를 지원한다:
*
*     1 라인  x 16 문자     2 라인 x 16 문자     4 라인 x 16 문자
*     1 라인  x 20 문자     2 라인 x 20 문자     4 라인 x 20 문자
*     1 라인  x 24 문자     2 라인 x 24 문자
*     1 라인  x 40 문자     2 라인 x 40 문자
*********************************************************************************************************
*/

/*$PAGE*/
/*
*********************************************************************************************************
*                                              인크루드 파일
*********************************************************************************************************
*/

#include "includes.h"

/*
*********************************************************************************************************
*                                               지역상수
*********************************************************************************************************
*/

                                       /* ----------------------  HD44780 명령어  -------------------- */
#define  DISP_CMD_CLS            0x01  /* Clr display : 디스플레이 클리어, 커서를 홈으로 위치시킨다    */
#define  DISP_CMD_FNCT           0x3B  /* Function Set: 데이터 길이 8비트, 1/16 듀티, 5x8 도트         */
#define  DISP_CMD_MODE           0x06  /* Entry mode  : 데이터 기록 시 자동으로 어드레스 증가          */
#define  DISP_CMD_ON_OFF         0x0C  /* Disp ON/OFF : 디스플레이 온, 커서 오프, 문자점멸 오프        */

/*
*********************************************************************************************************
*                                               지역변수
*********************************************************************************************************
*/

static  INT8U       DispMaxCols;       /* 열의 최대 숫자 (1라인당 문자의 개수)                         */
static  INT8U       DispMaxRows;       /* 행의 최대 숫자                                               */
static  OS_EVENT   *DispSem;           /* LCD용 세마포어                                               */


static  INT8U       DispBar1[] = {0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10};
static  INT8U       DispBar2[] = {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18};
static  INT8U       DispBar3[] = {0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C};
static  INT8U       DispBar4[] = {0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E};
static  INT8U       DispBar5[] = {0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F};

/*
*********************************************************************************************************
*                                             지역함수 원형
*********************************************************************************************************
*/

static  void        DispCursorSet(INT8U row, INT8U col);

/*$PAGE*/
/*
*********************************************************************************************************
*                                            문자 디스플레이
*
* 설명     : 표시장치에 한 개의 문자를 디스플레이 한다
* 전달인자 : 'row' 는 LCD에서 커서의 행 위치
*                  'row'는 0에서 'DispMaxRows - 1'까지의 값을 갖는다
*            'col' 는 LCD에서 커서의 열 위치
*                  'col'은 0에서 'DispMaxCols - 1'까지의 값을 갖는다
*            'c'   는 현재 행과 열의 위치에서 표시될 문자의 값
* 리턴값   : 없음
*********************************************************************************************************
*/

void  DispChar (INT8U row, INT8U col, char c)
{
    INT8U err;


    if (row < DispMaxRows && col < DispMaxCols) {
        OSSemPend(DispSem, 0, &err);        /* 표시장치의 배타적 액세스를 얻는다                       */
        DispCursorSet(row, col);            /* 커서를 ROW/COL에 위치시킨다                             */
        DispSel(DISP_SEL_DATA_REG);
        DispDataWr(c);                      /* 표시장치에 문자를 쓴다                                  */
        OSSemPost(DispSem);                 /* 액세스를 릴리즈한다                                     */
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                               라인 지우기
*
* 설명     : 한 개의 라인을 지우고 커서를 라인의 처음 위치로 보낸다
*
* 전달인자 : 'line' 은 지울 라인 넘버
*            0에서 'DispMaxRows - 1'까지의 값을 갖는다
* 리턴값   : 없음
*********************************************************************************************************
*/

void  DispClrLine (INT8U line)
{
    INT8U i;
    INT8U err;


    if (line < DispMaxRows) {
        OSSemPend(DispSem, 0, &err);             /* 표시장치의 배타적 액세스를 얻는다                  */
        DispCursorSet(line, 0);                  /* 지울 라인의 처음 위치로 커서를 보낸다              */
        DispSel(DISP_SEL_DATA_REG);              /* LCD의 데이터 레지스터를 선택한다                   */
        for (i = 0; i < DispMaxCols; i++) {      /* 현재 라인의 위치로 부터 모든 행에 ' '을 쓴다       */
            DispDataWr(' ');                     /* 현재 위치에 ASCII space 값을 쓴다                  */
        }
        DispCursorSet(line, 0);                  /* 커서를 라인의 처음 위치로 보낸다                   */
        OSSemPost(DispSem);                      /* 액세스를 릴리즈한다                                */
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                              스크린 지우기
*
* 설명 : 디스플레이 전체를 클리어한다
* 전달인자   : 없음
* 리턴값     : 없음
*********************************************************************************************************
*/

void  DispClrScr (void)
{
    INT8U err;


    OSSemPend(DispSem, 0, &err);       /* 표시장치의 배타적 액세스를 얻는다                            */
    DispSel(DISP_SEL_CMD_REG);         /* LCD의 명령 레지스터를 선택한다                               */
    DispDataWr(DISP_CMD_CLS);          /* 클리어 명령을 쓴다                                           */
    OSTimeDly(2);                      /* 2msec이상 기다린다(두개의 틱이면 충분함)                     */
    OSSemPost(DispSem);                /* 액세스를 릴리즈한다                                          */
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                     커서 임의 위치로 보내기 (내부용)
*
* 설명     : 커서를 LCD버퍼의 임의 위치로 보내다
* 전달인자 : 'row' 는 LCD에서 커서의 행 위치
*                  'row'는 0에서 'DispMaxRows - 1'까지의 값을 갖는다
*            'col' 는 LCD에서 커서의 열 위치
*                  'col'은 0에서 'DispMaxCols - 1'까지의 값을 갖는다
* 리턴값   : 없음
*********************************************************************************************************
*/

static  void  DispCursorSet (INT8U row, INT8U col)
{
    DispSel(DISP_SEL_CMD_REG);                             /* 명령어 레지스터 선택                     */
    switch (row) {
        case 0:
             if (DispMaxRows == 1) {                       /* 1 라인 LCD인 경우 예외적으로 처리한다    */
                 if (col < (DispMaxCols >> 1)) {
                     DispDataWr(0x80 + col);               /* 라인의 첫 번째 반은 0x80에서 시작        */
                 } else {                                  /* 라인의 두 번째 반은 0xC0에서 시작        */
                     DispDataWr(0xC0 + col - (DispMaxCols >> 1));
                 }
             } else {
                 DispDataWr(0x80 + col);                   /* LCD 라인1을 선택                         */
             }
             break;

        case 1:
             DispDataWr(0xC0 + col);                       /* LCD 라인2을 선택                         */
             break;

        case 2:
             DispDataWr(0x80 + DispMaxCols + col);         /* LCD 라인3을 선택                         */
             break;

        case 3:
             DispDataWr(0xC0 + DispMaxCols + col);         /* LCD 라인4을 선택                         */
             break;
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                               문자 정의
*
* 설명     : 사용자 문자에 대한 도트 패턴을 정의한다
* 전달인자 : 'id'  사용하고자 하는 도트 패턴에 대한 id
*            'pat' 도트 패턴을 가지고 있는 8바이트 행렬의 포인터
* 리턴값   : 없음
*********************************************************************************************************
*/

void  DispDefChar (INT8U id, INT8U *pat)
{
    INT8U err;
    INT8U i;


    OSSemPend(DispSem, 0, &err);            /* 표시장치의 배타적 액세스를 얻는다                       */
    DispSel(DISP_SEL_CMD_REG);              /* 명령어 레지스터를 선택한다                              */
    DispDataWr(0x40 + (id << 3));           /* CG RAM의 어드레스를 세트한다                            */
    DispSel(DISP_SEL_DATA_REG);             /* 데이터 레지스터를 선택한다                              */
    for (i = 0; i < 8; i++) {
        DispDataWr(*pat++);                 /* CG RAM에 패턴을 써 넣는다                               */
    }
    OSSemPost(DispSem);                     /* 액세스를 릴리즈한다                                     */
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                                 더미 함수
*
* 설명     : 이 함수는 아무 일도 하지 않는다.  몇 개의 NOP(No Operation)과 같은 동작을 하고
*            단지 몇 사이클의 CPU 타임을 소비하므로 짧은 딜레이 함수로 사용된다
* 전달인자 : 없음
* 리턴값   : 없음
*********************************************************************************************************
*/

void  DispDummy (void)
{
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                             수평 BAR를 표시
*
* 설명     : LCD모듈에 수평 BAR(bar 그래프)를 그려준다
* 전달인자 : 'row' 는 LCD에서 커서의 행 위치
*                  'row'는 0에서 'DispMaxRows - 1'까지의 값을 갖는다
*            'val' 는 수평 BAR의 값 
*                  이 값은 DispMaxCols * 5 이상 넘을 수 없다
* 리턴값   : 없음
* 노트     : 이 함수를 사용하려면, DispHorBarInit()를 먼저 호출해야 한다
*********************************************************************************************************
*/

void  DispHorBar (INT8U row, INT8U col, INT8U val)
{
    INT8U i;
    INT8U full;
    INT8U fract;
    INT8U err;


    full  = val / 5;                        /* 꽉 찬 블럭이 몇 개 ON 됐는지 확인한다                   */
    fract = val % 5;                        /* 블럭의 위치를 계산                                      */
    if (row < DispMaxRows && (col + full - 1) < DispMaxCols) {
        OSSemPend(DispSem, 0, &err);        /* 표시장치의 배타적 액세스를 얻는다                       */
        i = 0;                              /* Set counter to limit column to maximum allowable column */
        DispCursorSet(row, col);            /* 바그래프의 시작 위치로 커서를 위치시킨다                */
        DispSel(DISP_SEL_DATA_REG);
        while (full > 0) {                  /* 꽉 찬 블럭을 모두 쓴다                                  */
            DispDataWr(5);                  /* 사용자 문자 #5(꽉 찬 블럭)를 쓴다                       */
            i++;                            /* 리미트 카운터 증가                                      */
            full--;
        }
        if (fract > 0) {
            DispDataWr(fract);              /* 사용자 문자 #'fract'(일부만 채운블럭)을 쓴다            */
        }
        OSSemPost(DispSem);                 /* 액세스를 릴리즈한다                                     */
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                            수평 BAR 초기화
*
* 설명     : 바그래프 기능을 초기화한다  You must
*            DispHorBar()를 호출하기 전에 반드시 이 함수를 호출해야 한다
* 전달인자 : 없음
* 리턴값   : 없음
*********************************************************************************************************
*/

void  DispHorBarInit (void)
{
    DispDefChar(1, &DispBar1[0]);
    DispDefChar(2, &DispBar2[0]);
    DispDefChar(3, &DispBar3[0]);
    DispDefChar(4, &DispBar4[0]);
    DispDefChar(5, &DispBar5[0]);
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                       디스플레이 드라이버 초기화
*
* 설명     : 디스플레이 드라이버를 초기화한다
* 전달인자 : maxrows      LCD 디스플레이의 라인넘버 (1 to 4)
*            maxcols      라인당 열(column)의 숫자
* 리턴값   : 없음
* 노트     : - DispInit() 는 커널 서비스(시간지연)를 필요로 하므로 멀티태스킹 커널이 시작된 후에
*              호출돼야 한다
*            - DispInit() 시스템 초기화 시 한번만 호출돼야 한다
*********************************************************************************************************
*/

void  DispInit (INT8U maxrows, INT8U maxcols)
{
    DispInitPort();                    /* 디스플레이 드라이버에서 사용하는 I/O포트를 초기화 한다       */
    DispMaxRows = maxrows;
    DispMaxCols = maxcols;
    DispSem     = OSSemCreate(1);      /* 디스플레이용 세마포어 생성                                   */

                                       /* 디스플레이 모듈 초기화                                       */
    DispSel(DISP_SEL_CMD_REG);         /* 명령어 레지스터를 선택한다                                   */
    OSTimeDlyHMSM(0, 0, 0, 50);        /* 파워-온 후  15msec이상 딜레이를 준다(50msec면 충분함)        */
    DispDataWr(DISP_CMD_FNCT);         /* Function Set: 데이터 길이 8비트, 1/16 듀티, 5x8 도트         */
    OSTimeDly(2);                      /* 비지 프래그는 아직 확인 하면 안됨!                           */
    DispDataWr(DISP_CMD_FNCT);         /* 위의 명령을 4번 쓴다!                                        */
    OSTimeDly(2);                      /*     히다찌 HD44780 데이터 쉬트의 권장 사항임                 */
    DispDataWr(DISP_CMD_FNCT);
    OSTimeDly(2);
    DispDataWr(DISP_CMD_FNCT);
    OSTimeDly(2);

    DispDataWr(DISP_CMD_ON_OFF);       /* Disp ON/OFF : 디스플레이 온, 커서 오프, 문자점멸 오프        */
    DispDataWr(DISP_CMD_MODE);         /* Entry mode  : 데이터 기록 시 자동으로 어드레스 증가          */
    DispDataWr(DISP_CMD_CLS);          /* 디스플레이 클리어 명령을 쓴다                                */
    OSTimeDly(2);                      /* 최소한 2msec이상 딜레이 (2개의 틱이면 충분)                  */
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                         ASCII문자열 디스플레이
*
* 설명     : 표시장치에 ASCII 문자열을 디스플레이 한다
* 전달인자 : 'row' 는 LCD에서 커서의 행 위치
*                  'row'는 0에서 'DispMaxRows - 1'까지의 값을 갖는다
*            'col' 는 LCD에서 커서의 열 위치
*                  'col'은 0에서 'DispMaxCols - 1'까지의 값을 갖는다
*            's'   row/col에 디스플레이 하고자 하는 ASCII문자열
*
* 리턴값   : 없음
*********************************************************************************************************
*/

void  DispStr (INT8U row, INT8U col, char *s)
{
    INT8U i;
    INT8U err;


    if (row < DispMaxRows && col < DispMaxCols) {
        OSSemPend(DispSem, 0, &err);        /* 표시장치의 배타적 액세스를 얻는다                       */
        DispCursorSet(row, col);            /* 커서를 ROW/COL에 위치시킨다                             */
        DispSel(DISP_SEL_DATA_REG);
        i = col;                            /* 최대 허용가능한 값으로 리미트 카운터를 세트한다         */
        while (i < DispMaxCols && *s) {     /* (str+limit)와 DispMaxCols 사이에 문자를 쓴다            */
            DispDataWr(*s++);               /* 표시장치에 문자를 쓴다                                  */
            i++;                            /* 리미트 카운터 증가                                      */
        }
        OSSemPost(DispSem);                 /* 액세스를 릴리즈한다                                     */
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                     디스플레이 장치에 데이터 쓰기
*
* 설명     : 디스플레이 장치에 한바이트 데이터를 쓴다
* 전달인자 : 'data'  써넣을 데이터
* 리턴값   : 없음
* 노트     : 데이터 쓰기 사이에 최소한 40usec의 딜레이를 주기 위해서는 DISP_DLY_CNTS(LCD.H) 값을 변경할
*            필요가 있을 것이다. 필자가 시험에 사용한 모듈은 실제로 80usec의 딜레이가 필요했다!
*            LCD모듈의 글씨가 깜박거리거나 문자가 임의의 위치에 보이면 DISP_DLY_CNTS 값을 증가시켜 보라
*
*********************************************************************************************************
*/

#ifndef CFG_C
void  DispDataWr (INT8U data)
{
    INT8U  dly;


    outp(DISP_PORT_DATA, data);                  /* 디스플레이 모듈에 데이터를 쓴다                    */
    outp(DISP_PORT_CMD,  0x01);                  /* E라인을 High로 세트한다                            */
    DispDummy();                                 /* 약 1usec 딜레이                                    */
    outp(DISP_PORT_CMD,  0x00);                  /* E라인을 Low로 세트한다                             */
    for (dly = DISP_DLY_CNTS; dly > 0; dly--) {  /* 최소한 40 usec딜레이                               */
        DispDummy();
    }
}
#endif

/*
*********************************************************************************************************
*                                   디스플레이 드라이버 I/O포트 초기화
*
* 설명     : 디스플레이 드라이버에서 사용하는 I/O포트를 초기화 한다
* 전달인자 : 없음
* 리턴값   : 없음
*********************************************************************************************************
*/

#ifndef CFG_C
void  DispInitPort (void)
{
    outp(DISP_PORT_CMD, 0x82);         /* 모드0 : A 출력, B 입력, C 출력                               */
}
#endif

/*
*********************************************************************************************************
*                                      명령어/데이터 레지스터 선택
*
* 설명     : 레지스터를 선택한다
* 전달인자 : 없음
*********************************************************************************************************
*/

#ifndef CFG_C
void  DispSel (INT8U sel)
{
    if (sel == DISP_SEL_CMD_REG) {
        outp(DISP_PORT_CMD, 0x02);     /* 명령어 레지스터 선택 (RS low)                                */
    } else {
        outp(DISP_PORT_CMD, 0x03);     /* 데이터 레지스터 선택 (RS high)                               */
    }
}
#endif
