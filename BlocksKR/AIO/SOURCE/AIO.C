/*
*********************************************************************************************************
*                                          Analog I/O Module
*
*                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
*                                          All Rights Reserved
*
* Filename   : AIO.C
* Programmer : Jean J. Labrosse
* Translated by : Won-Ho, Sung
*********************************************************************************************************
*/

/*
*********************************************************************************************************
*                                              인크루드 파일
*********************************************************************************************************
*/

#define   AIO_GLOBALS
#include "includes.h"

/*
*********************************************************************************************************
*                                                지역변수
*********************************************************************************************************
*/

static  OS_STK      AIOTaskStk[AIO_TASK_STK_SIZE];
static  OS_EVENT   *AIOSem;

/*
*********************************************************************************************************
*                                             지역함수 원형
*********************************************************************************************************
*/

        void        AIOTask(void *data);

static  void        AIInit(void);
static  void        AIUpdate(void);

static  void        AOInit(void);
static  void        AOUpdate(void);

/*$PAGE*/
/*
*********************************************************************************************************
*                                   아날로그 입력 채널의 교정 인자 설정
*
* 설명     : 이 함수는 아날로그 입력 채널을 설정하기 위해 사용한다.
* 전달인자 : n        설정하고자 하는 아날로그 입력채널:
*            gain     교정 이득
*            offset   교정 오프셋
* 리턴값   : 0        성공.
*            1        무효한 아날로그 입력 채널.
*********************************************************************************************************
*/

INT8U  AICfgCal (INT8U n, FP32 gain, FP32 offset)
{
    INT8U err;
    AIO  *paio;


    if (n < AIO_MAX_AI) {
        paio               = &AITbl[n];               /* 아날로그 입력채널 구조체를 지시한다           */
        OSSemPend(AIOSem, 0, &err);                   /* AI 채널의 독점적 액세스를 얻는다              */
        paio->AIOCalGain   = gain;                    /* 구조체에 교정 이득과 오프셋 값을 저장한다     */
        paio->AIOCalOffset = offset;
        paio->AIOGain      = paio->AIOCalGain   * paio->AIOConvGain;      /* 전체 이득을 계산한다      */
        paio->AIOOffset    = paio->AIOCalOffset + paio->AIOConvOffset;    /* 전체 오프셋을 계산한다    */
        OSSemPost(AIOSem);                                                /* AI 채널을 릴리즈 한다     */
        return (0);
    } else {
        return (1);
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                   아날로그 입력 채널의 변환 인자 설정
*
* 설명     : 이 함수는 아날로그 입력 채널을 설정하기 위해 사용한다.
* 전달인자 : n        설정하고자 하는 아날로그 입력채널(0..AIO_MAX_AI-1).
*            gain     변환 이득
*            offset   변환 오프셋
*            pass     패스 카운트 값
* 리턴값   : 0        성공.
*            1        무효한 아날로그 입력 채널.
*********************************************************************************************************
*/

INT8U  AICfgConv (INT8U n, FP32 gain, FP32 offset, INT8U pass)
{
    INT8U err;
    AIO  *paio;


    if (n < AIO_MAX_AI) {
        paio                = &AITbl[n];              /* 아날로그 입력 채널을 가리킨다                 */
        OSSemPend(AIOSem, 0, &err);                   /* AI 채널에 대한 독점적 액세스를 얻는다         */
        paio->AIOConvGain   = gain;                   /* 구조체에 변환 이득과 오프셋을 저장한다        */
        paio->AIOConvOffset = offset;
        paio->AIOGain       = paio->AIOCalGain   * paio->AIOConvGain;     /* 전체 이득을 계산한다      */
        paio->AIOOffset     = paio->AIOCalOffset + paio->AIOConvOffset;   /* 전체 오프셋을 계산한다    */
        paio->AIOPassCnts   = pass;
        OSSemPost(AIOSem);                                                /* AI 채널을 릴리즈 한다     */
        return (0);
    } else {
        return (1);
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                   아날로그 입력 채널의 배율 인자 설정
*
* 설명     : 이 함수는 아날로그 입력채널과 관련된 배율인자를 설정하는데 사용한다.
*
* 전달인자 : n        설정하고자 하는 아날로그 입력채널(0..AIO_MAX_AI-1).
*            arg      배율 함수에서 필요한 전달인자의 포인터
*            fnct     배율 함수의 포인터
* 리턴값   : 0        성공.
*            1        무효한 아날로그 입력 채널.
*********************************************************************************************************
*/

INT8U  AICfgScaling (INT8U n, void (*fnct)(AIO *paio), void *arg)
{
    AIO *paio;


    if (n < AIO_MAX_AI) {
        paio                  = &AITbl[n];            /* 포인터를 이용해서 구조체를 빠르게 액세스 한다 */
        OS_ENTER_CRITICAL();
        paio->AIOScaleFnct    = (void (*)())fnct;
        paio->AIOScaleFnctArg = arg;
        OS_EXIT_CRITICAL();
        return (0);
    } else {
        return (1);
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                  아날로그 입력 채널에서 현재 값 획득
*
* 설명     : 이 함수는 아날로그 입력채널의 현재 값을 공학단위로 얻는데 사용한다.
*
* 전달인자 : n     아날로그 입력 채널(0..AIO_MAX_AI-1).
*            pval  아날로그 입력 채널의 공학단위 값이 저장될 포인터
* 리턴값   : 0     성공.
*            1     무효한 아날로그 입력 채널.
*                  이 경우, 포인터가 지정하는 변수의 값은 변경되지 않는다.
*********************************************************************************************************
*/

INT8U  AIGet (INT8U n, FP32 *pval)
{
    AIO  *paio;


    if (n < AIO_MAX_AI) {
        paio  = &AITbl[n];
        OS_ENTER_CRITICAL();           /* AI 채널의 독점적 액세스 획득                                 */
        *pval = paio->AIOEU;           /* 아날로그 입력 채널의 공학단위 값을 얻는다                    */
        OS_EXIT_CRITICAL();            /* AI 채널을 릴리즈 한다                                        */
        return (0);
    } else {
        return (1);
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                         아날로그 입력 초기화
*
* 설명     : 이 함수는 모든 아날로그 입력 채널을 초기화 한다.
* 전달인자 : 없음
* 리턴값   : 없음.
*********************************************************************************************************
*/

static  void  AIInit (void)
{
    INT8U   i;
    AIO    *paio;


    paio = &AITbl[0];
    for (i = 0; i < AIO_MAX_AI; i++) {
        paio->AIOBypassEn     =  FALSE;           /* 바이패스 비활성화                                 */
        paio->AIORaw          =  0x0000;          /* ADC 또는 DAC 값                                   */
        paio->AIOEU           = (FP32)0.0;        /* 공학 단위 값                                      */
        paio->AIOGain         = (FP32)1.0;        /* 전체 이득                                         */
        paio->AIOOffset       = (FP32)0.0;        /* 전체 오프셋                                       */
        paio->AIOLim          =       0;
        paio->AIOPassCnts     =       1;          /* 패스 카운트                                       */
        paio->AIOPassCtr      =       1;          /* 패스 카운터                                       */
        paio->AIOCalGain      = (FP32)1.0;        /* 교정 이득                                         */
        paio->AIOCalOffset    = (FP32)0.0;        /* 교정 오프셋                                       */
        paio->AIOConvGain     = (FP32)1.0;        /* 변환 이득                                         */
        paio->AIOConvOffset   = (FP32)0.0;        /* 변환 오프셋                                       */
        paio->AIOScaleIn      = (FP32)0.0;        /* 배율 함수의 입력                                  */
        paio->AIOScaleOut     = (FP32)0.0;        /* 배율 함수의 출력                                  */
        paio->AIOScaleFnct    = (void *)0;        /* 배율 함수를 설정하지 않는다                       */
        paio->AIOScaleFnctArg = (void *)0;        /* 배율 함수의 인자를 설정하지 않는다                */
        paio++;
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                       아날로그 I/O 관리자 초기화
*
* 설명     : 이 함수는 아날로그 I/O 관리자 모듈을 초기화 한다.
* 전달인자 : 없음
* 리턴값   : 없음.
*********************************************************************************************************
*/

void  AIOInit (void)
{
    INT8U   err;


    AIInit();
    AOInit();
    AIOInitIO();
    AIOSem = OSSemCreate(1);                     /* AIO에 대한 배타적 접근용 세마포어 생성             */
    OSTaskCreateExt(AIOTask, (void *)0, &AIOTaskStk[AIO_TASK_STK_SIZE], AIO_TASK_PRIO,
                    AIO_TASK_PRIO, &AIOTaskStk[0], AIO_TASK_STK_SIZE, (void *)0, OS_TASK_OPT_SAVE_FP);
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                       아날로그 I/O 관리자 태스크
*
* 설명     : 이 태스크는 AIOInit()에 의해 생성되고 아날로그 입력과 출력을 갱신하는 일을 한다.
*            AIOTask()는 AIO_TASK_DLY msec 마다 실행된다.
*
* 전달인자 : 없음.
* 리턴값   : 없음.
*********************************************************************************************************
*/

void  AIOTask (void *data)
{
    INT8U err;


    data = data;                                 /* 컴파일러 경고를 없앤다                             */
    for (;;) {
        OSTimeDlyHMSM(0, 0, 0, AIO_TASK_DLY);    /* AIO 관리자를 실행할 때의 시간지연                  */

        OSSemPend(AIOSem, 0, &err);              /* AI 채널에 대한 독점적 액세스를 획득한다            */
        AIUpdate();                              /* 모든 AI 채널을 갱신한다                            */
        OSSemPost(AIOSem);                       /* 세마포어 릴리즈                                    */

        OSSemPend(AIOSem, 0, &err);              /* AO 채널에 대한 독점적 액세스를 획득한다            */
        AOUpdate();                              /* 모든 AO 채널을 갱신한다                            */
        OSSemPost(AIOSem);                       /* 세마포어 릴리즈                                    */
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                바이패스된 아날로그 입력 채널 값 설정
*
* 설명     : 이 함수는 바이패스 되는 아날로그 입력채널의 공학단위 값을 설정하는데 사용한다.
*            이 함수는 아날로그 입력 채널에 센서가 있는 것 처럼 흉내내도록 해준다.
*            이 함수는 바이패스 스위치가 열려 있을 때만 유효하다.
* 전달인자 : n     아날로그 입력 채널(0..AIO_MAX_AI-1).
*            val   바이패스된 아날로그 입력 채널의 값:
* 리턴값   : 0     성공.
*            1     무효한 아날로그 입력 채널.
*            2     AIOBypassEn이 TRUE로 설정되어 있지 않은 경우.
*********************************************************************************************************
*/

INT8U  AISetBypass (INT8U n, FP32 val)
{
    AIO   *paio;


    if (n < AIO_MAX_AI) {
        paio = &AITbl[n];                        /* 포인터를 이용해서 구조체를 빠르게 액세스 한다      */
        if (paio->AIOBypassEn == TRUE) {         /* 아날로그 입력 채널의 바이패스가 활성화 되었는가    */
            OS_ENTER_CRITICAL();
            paio->AIOEU = val;                   /* 예, 채널에 대한 새 값을 설정                       */
            OS_EXIT_CRITICAL();
            return (0);
        } else {
            return (2);
        }
    } else {
        return (1);
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                       바이패스 스위치의 상태 설정
*
* 설명     : 이 함수는 바이패스 스위치의 상태를 설정하기 위해 사용한다.
*            아날로그 입력 채널은 스위치가 열려 있을 때 바이패스 된다(즉, AIOBypassEn을 TRUE로 설정).
* 전달인자 : n      아날로그 입력 채널(0..AIO_MAX_AI-1).
*            state  바이패스 스위치의 상태:
*                   FALSE 바이패스를 비활성화 한다 (즉, 바이패스 스위치가 닫힌다)
*                   TRUE  바이패스를 활성화 한다 (즉, 바이패스 스위치가 열린다)
* 리턴값   : 0      성공.
*            1      무효한 아날로그 입력 채널.
*********************************************************************************************************
*/

INT8U  AISetBypassEn (INT8U n, BOOLEAN state)
{
    if (n < AIO_MAX_AI) {
        AITbl[n].AIOBypassEn = state;
        return (0);
    } else {
        return (1);
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                    모든 아날로그 입력 채널을 갱신한다
*
* 설명     : 이 함수는 모든 아날로그 입력 채널을 처리한다.
* 전달인자 : 없음.
* 리턴값   : 없음.
*********************************************************************************************************
*/

static  void  AIUpdate (void)
{
    INT8U   i;
    AIO    *paio;


    paio = &AITbl[0];                            /* 첫 번째 아날로그 입력 채널을 가리킨다              */
    for (i = 0; i < AIO_MAX_AI; i++) {           /* 모든 아날로그 입력 채널을 갱신한다                 */
        if (paio->AIOBypassEn == FALSE) {        /* 아날로그 입력 채널의 바이패스가 비활성화 되었는가  */
            paio->AIOPassCtr--;                  /* 패스 카운터 감소                                   */
            if (paio->AIOPassCtr == 0) {         /* 패스카운터가 0이면, 아날로그 입력을 읽고 배율한다  */
                paio->AIOPassCtr = paio->AIOPassCnts;                /* 패스 카운터를 로드한다         */
                paio->AIORaw     = AIRd(i);                          /* 이 채널의 ADC를 읽는다         */
                paio->AIOScaleIn = ((FP32)paio->AIORaw + paio->AIOOffset) * paio->AIOGain;
                if ((void *)paio->AIOScaleFnct != (void *)0) {       /* 함수가 정의되었는가?           */
                    (*paio->AIOScaleFnct)(paio);                     /* 예, 함수를 실행                */
                } else {
                    paio->AIOScaleOut = paio->AIOScaleIn;            /* 아니오, 데이터만 복사한다      */
                }
                paio->AIOEU = paio->AIOScaleOut;                     /* 공학단위 값 저장               */
            }
        }
        paio++;                                                      /* 다음 AI 채널을 가리킨다        */
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                   아날로그 출력채널의 교정인자 설정
*
* 설명     : 이 함수는 아날로그 출력채널을 설정하는데 사용한다.
* 전달인자 : n        설정하고자 하는 아날로그 출력채널(0..AIO_MAX_AO-1).
*            gain     교정 이득
*            offset   교정 오프셋
* 리턴값   : 0        성공.
*            1        무효한 아날로그 출력 채널.
*********************************************************************************************************
*/

INT8U  AOCfgCal (INT8U n, FP32 gain, FP32 offset)
{
    INT8U  err;
    AIO   *paio;


    if (n < AIO_MAX_AO) {
        paio               = &AOTbl[n];               /* 아날로그 출력 구조체를 가리킨다               */
        OSSemPend(AIOSem, 0, &err);                   /* AO 채널의 독점적 액세스를 획득한다            */
        paio->AIOCalGain   = gain;                    /* 새 교정 이득과 오프셋 설정                    */
        paio->AIOCalOffset = offset;
        paio->AIOGain      = paio->AIOCalGain   * paio->AIOConvGain;      /* 전체 이득 계산            */
        paio->AIOOffset    = paio->AIOCalOffset + paio->AIOConvOffset;    /* 전체 오프셋 계산          */
        OSSemPost(AIOSem);                                                /* AO 채널 릴리즈            */
        return (0);
    } else {
        return (1);
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                   아날로그 출력채널의 변환인자 설정
*
* 설명     : 이 함수는 아날로그 출력채널을 설정하는데 사용한다.
* 전달인자 : n        설정하고자 하는 아날로그 출력채널(0..AIO_MAX_AO-1).
*            gain     변환 이득
*            offset   변환 오프셋
*            pass     패스 카운터 값
* 리턴값   : 0        성공.
*            1        무효한 아날로그 출력 채널.
*********************************************************************************************************
*/

INT8U  AOCfgConv (INT8U n, FP32 gain, FP32 offset, INT16S lim, INT8U pass)
{
    INT8U err;
    AIO  *paio;


    if (n < AIO_MAX_AO) {
        paio                = &AOTbl[n];              /* 아날로그 출력 구조체를 가리킨다               */
        OSSemPend(AIOSem, 0, &err);                   /* AO 채널의 독점적 액세스를 획득한다            */
        paio->AIOConvGain   = gain;                   /* 새 변환 이득과 오프셋 설정                    */
        paio->AIOConvOffset = offset;
        paio->AIOGain       = paio->AIOCalGain   * paio->AIOConvGain;     /* 전체 이득 계산            */
        paio->AIOOffset     = paio->AIOCalOffset + paio->AIOConvOffset;   /* 전체 오프셋 계산          */
        paio->AIOLim        = lim;                                        
        paio->AIOPassCnts   = pass;
        OSSemPost(AIOSem);                                                /* AO 채널 릴리즈            */
        return (0);
    } else {
        return (1);
    }
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                   아날로그 출력채널의 배율인자 설정
*
* 설명     : 이 함수는 아날로그 출력채널과 관련된 배율인자를 설정하는데 사용한다.
*
* 전달인자 : n        설정하고자 하는 아날로그 출력채널(0..AIO_MAX_AO-1).
*            arg      배율함수에서 필요한 전달인자의 포인터
*            fnct     배율함수의 포인터
* 리턴값   : 0        성공.
*            1        무효한 아날로그 출력 채널.
*********************************************************************************************************
*/

INT8U  AOCfgScaling (INT8U n, void (*fnct)(AIO *paio), void *arg)
{
    AIO *paio;


    if (n < AIO_MAX_AO) {
        paio                  = &AOTbl[n];            /* 포인터를 이용해서 구조체를 빠르게 액세스 한다 */
        OS_ENTER_CRITICAL();
        paio->AIOScaleFnct    = (void (*)())fnct;
        paio->AIOScaleFnctArg = arg;
        OS_EXIT_CRITICAL();
        return (0);
    } else {
        return (1);
    }
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                         아날로그 출력 초기화
*
* 설명     : 이 함수는 모든 아날로그 출력을 초기화 한다.
* 전달인자 : 없음
* 리턴값   : 없음.
*********************************************************************************************************
*/

static  void  AOInit (void)
{
    INT8U   i;
    AIO    *paio;


    paio = &AOTbl[0];
    for (i = 0; i < AIO_MAX_AO; i++) {
        paio->AIOBypassEn     = FALSE;           /* 바이패스 비활성화                                  */
        paio->AIORaw          = 0x0000;          /* ADC 또는 DAC 값 초기화                             */
        paio->AIOEU           =  (FP32)0.0;      /* AI 채널에 공학단위 초기값 설정                     */
        paio->AIOGain         =  (FP32)1.0;      /* 전체 이득                                          */
        paio->AIOOffset       =  (FP32)0.0;      /* 전체 오프셋                                        */
        paio->AIOLim          =      0;          /* 아날로그 출력 채널 최대 카운트                     */
        paio->AIOPassCnts     =      1;          /* 패스 카운트                                        */
        paio->AIOPassCtr      =      1;          /* 패스 카운터                                        */
        paio->AIOCalGain      =  (FP32)1.0;      /* 교정 이득                                          */
        paio->AIOCalOffset    =  (FP32)0.0;      /* 교정 오프셋                                        */
        paio->AIOConvGain     =  (FP32)1.0;      /* 변환 이득                                          */
        paio->AIOConvOffset   =  (FP32)0.0;      /* 변환 오프셋                                        */
        paio->AIOScaleIn      =  (FP32)0.0;      /* 배율함수 입력                                      */
        paio->AIOScaleOut     =  (FP32)0.0;      /* 배율함수 출력                                      */
        paio->AIOScaleFnct    = (void *)0;       /* 배율함수를 설정하지 않는다                         */
        paio->AIOScaleFnctArg = (void *)0;       /* 배율함수의 전달인자를 설정하지 않는다              */
        paio++;
    }
}
/*$PAGE*/
/*
*********************************************************************************************************
*                                아날로그 출력의 공학단위 값을 설정한다
*
* 설명     : 이 함수는 아날로그 출력채널에 공학단위 값을 설정하는데 사용한다.
*
* 전달인자 : n     아날로그 출력채널(0..AIO_MAX_AO-1).
*            val   원하는 공학단위의 아날로그 출력 값
* 리턴값   : 0     성공.
*            1     무효한 아날로그 출력 채널.
*********************************************************************************************************
*/

INT8U  AOSet (INT8U n, FP32 val)
{
    if (n < AIO_MAX_AO) {
        OS_ENTER_CRITICAL();
        AOTbl[n].AIOEU = val;          /* 아날로그 출력 채널의 공학단위 값 설정                        */
        OS_EXIT_CRITICAL();
        return (0);
    } else {
        return (1);
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                              바이패스된 아날로그 출력채널의 상태 설정
*
* 설명     : 이 함수는 바이패스된 아날로그 출력채널의 값을 공학단위로 설정한다.
* 전달인자 : n     아날로그 출력채널(0..AIO_MAX_AO-1).
*            val   바이패스된 아날로그 출력채널의 값:
* 리턴값   : 0     성공.
*            1     무효한 아날로그 출력 채널.
*            2     AIOBypassEn 이 TRUE로 설정되어 있지 않은 경우
*********************************************************************************************************
*/

INT8U  AOSetBypass (INT8U n, FP32 val)
{
    AIO *paio;


    if (n < AIO_MAX_AO) {
        paio = &AOTbl[n];                        /* 포인터를 이용해서 구조체를 빠르게 액세스 한다      */
        if (paio->AIOBypassEn == TRUE) {         /* 출력 채널이 바이패스 모드인가                      */
            OS_ENTER_CRITICAL();
            paio->AIOScaleIn = val;              /* 예, 채널에 새 값을 설정한다                        */
            OS_EXIT_CRITICAL();
            return (0);
        } else {
            return (2);
        }
    } else {
        return (1);
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                       바이패스 스위치 상태 설정
*
* 설명     : 이 함수는 바이패스 스위치의 상태를 설정하는데 사용한다. 아날로그 출력 채널은
*            스위치가 열려 있을 때 바이패스 된다(즉 AIOBypassEn이 TRUE로 설정될 때).
* 전달인자 : n      아날로그 출력채널(0..AIO_MAX_AO-1).
*            state  바이패스 스위치의 상태:
*                   FALSE  바이패스를 비활성화 한다 (즉 스위치가 닫힘)
*                   TRUE   바이패스를 활성화 한다 (즉 스위치가 열림)
* 리턴값   : 0      성공.
*            1      무효한 아날로그 출력 채널.
*********************************************************************************************************
*/

INT8U  AOSetBypassEn (INT8U n, BOOLEAN state)
{
    INT8U err;


    if (n < AIO_MAX_AO) {
        AOTbl[n].AIOBypassEn = state;
        return (0);
    } else {
        return (1);
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                     모든 아날로그 출력 채널 갱신
*
* 설명     : 이 함수는 모든 아날로그 출력 채널을 처리한다.
* 전달인자 : 없음.
* 리턴값   : 없음.
*********************************************************************************************************
*/

static  void  AOUpdate (void)
{
    INT8U     i;
    AIO      *paio;
    INT16S    raw;


    paio = &AOTbl[0];                            /* 아날로그 출력 채널의 첫 항목을 가리킨다            */
    for (i = 0; i < AIO_MAX_AO; i++) {           /* 모든 아날로그 출력 채널을 갱신한다                 */
        if (paio->AIOBypassEn == FALSE) {        /* 출력 채널이 바이패스 모드인가                      */
            paio->AIOScaleIn = paio->AIOEU;      /* 아니오                                             */
        }
        paio->AIOPassCtr--;                      /* 패스카운터를 감소한다                              */
        if (paio->AIOPassCtr == 0) {             /* 패스 카운터가 0이 되면 AI를 읽고 배율한다          */
            paio->AIOPassCtr = paio->AIOPassCnts;          /* 패스 카운터를 다시 로드한다              */
            if ((void *)paio->AIOScaleFnct != (void *)0) { /* 배율함수가 정의되었는가                  */
                (*paio->AIOScaleFnct)(paio);               /* 예, 함수를 실행한다                      */
            } else {
                paio->AIOScaleOut = paio->AIOScaleIn;      /* 아니오                                   */
            }
            raw = (INT16S)(paio->AIOScaleOut * paio->AIOGain + paio->AIOOffset);
            if (raw > paio->AIOLim) {                      /* 최대 DAC 값을 초과했는가                 */
                raw = paio->AIOLim;
            } else if (raw < 0) {                          /* DAC 값은 항상 0보다 커야한다             */
                raw = 0;
            }
            paio->AIORaw = raw;
            AOWr(i, paio->AIORaw);                         /* 값을 DAC로 출력한다                      */
        }
        paio++;                                            /* 다음 AO채널을 카리킨다                   */
    }
}

/*$PAGE*/
#ifndef CFG_C
/*
*********************************************************************************************************
*                                           물리적 I/O 초기화
*
* 설명     : 이 함수는 AIO 드라이버에서 사용하는 물리적 I/O를 초기화 하기 위해서
*            AIOInit()에 의해 호출된다.
* 전달인자 : 없음.
* 리턴값   : 없음.
*********************************************************************************************************
*/

void  AIOInitIO (void)
{
    /* 여기에 ADC와 DAC를 초기화 하는 코드를 삽입한다                                                  */
    /* DAC에 알려진 값을 출력해야 한다                                                                 */
}

/*
*********************************************************************************************************
*                                           물리적 입력 읽기
*
* 설명     : 이 함수는 물리적 ADC채널을 읽기 위해 호출된다. 이 함수는 또한 하나 이상의 입력이
*            ADC에 연결되어 있는 경우 멀티플렉서를 제어해야 한다.
* 전달인자 : ch     ADC의 논리적 채널 번호(0..AIO_MAX_AI-1).
* 리턴값   : 물리적 장치에서 읽은 변환 값.
*********************************************************************************************************
*/

INT16S  AIRd (INT8U ch)
{
    /* 여기에 ADC의 값을 읽는 코드를 삽입해야 한다                                                     */
    /* AIRd()는 논리적 채널 번호를 넘겨 받는다. 이 채널 번호를 물리적 ADC와 매핑되도록 변환해야 한다   */
    /* 이 변환은 MUX의 채널을 선택하거나 ADC가 위치한 어드레스를 선택하는 일 등을 말한다               */                                                                                                */
    /* AIRd() 는 다음과 같은 일을 수행한다                                                             */
    /*     1) 적절한 MUX. 채널을 선택한다                                                              */
    /*     2) MUX.가 안정되기를 기다린다                                                               */
    /*     3) 변환시작                                                                                 */
    /*     4) ADC가 변환을 완료할 때까지 대기한다                                                      */
    /*     5) ADC로부터 값을 읽는다                                                                    */
    /*     6) 읽은 값을 호출함수로 넘겨준다                                                            */

    return (ch);
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                           물리적 출력 갱신
*
* 설명     : 이 함수는 적절한 아날로그 출력 장치(DAC)로 가공되지 않은 값을 써 넣을 때 사용한다.
*            하나 이상의 DAC가 사용될 경우 적절한 DAC를 선택해야 한다.
*
* 전달인자 : ch     DAC의 논리 채널 번호 (0..AIO_MAX_AO-1).
*            cnts   DAC에 써 넣을 값
* 리턴값   : 없음.
*********************************************************************************************************
*/

void  AOWr (INT8U ch, INT16S cnts)
{
    ch   = ch;
    cnts = cnts;

    /* 여기에 DAC를 갱신하는 코드를 삽입한다                                                           */
    /* AOWr()는 논리적 채널 번호를 넘겨 받는다. 이 채널 번호는 적절히 변환 되어야 한다                 */
    /* 이 변환은 DAC가 위치한 실제 물리적 포트 번호나 어드레스를 선택하는 일을 말한다                  */
    /* AOWr()는 논리적 채널 번호에 의해 선택된 DAC에 출력 값을 써 넣는 일을 한다                       */
}
#endif
