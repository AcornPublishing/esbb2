/*
*********************************************************************************************************
*                                  Embedded Systems Building Blocks
*                               Complete and Ready-to-Use Modules in C
*
*                                           Configuration File
*
*                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
*                                           All Rights Reserved
*
* Filename   : CFG.C
* Programmer : Jean J. Labrosse
* Translated by : Won-Ho, Sung
*********************************************************************************************************
*/

#include "includes.h"

static  INT16S  AITestCnts;

/*$PAGE*/
/*
*********************************************************************************************************
*                                                키보드
*                                            I/O 포트 초기화
*********************************************************************************************************
*/

#if  MODULE_KEY_MN
void  KeyInitPort (void)
{
    outp(KEY_PORT_CW, 0x82);                    /* 82C55A 초기화 : A=출력, B=입력(COLS), C=출력 (ROWS) */
}

/*
*********************************************************************************************************
*                                                키보드
*                                             행을 선택한다
*
* 설명      : 이 함수는 키보드의 행을 선택하기 위해서 호출된다.
* 전달인자  : row ; 행 번호, (0..7) 또는 KEY_ALL_ROWS
* 리턴값    : 없음
* 노트      : 행은 LOW를 출력함으로써 선택된다.
*********************************************************************************************************
*/

void  KeySelRow (INT8U row)
{
    if (row == KEY_ALL_ROWS) {
        outp(KEY_PORT_ROW, 0x00);                /* 모든 행을 LOW로 한다                               */
    } else {
        outp(KEY_PORT_ROW, ~(1 << row));         /* 원하는 행을 LOW로 한다                             */
    }
}

/*
*********************************************************************************************************
*                                                키보드
*                                              열을 읽는다
*
* 설명      : 이 함수는 열 입력을 읽기 위해 호출된다.
* 전달인자  : 없음
* 리턴값    : 열 포트 신호의 컴플리먼트. 따라서 1이 키가 눌림을 의미한다
*********************************************************************************************************
*/

INT8U  KeyGetCol (void)
{
    return (~inp(KEY_PORT_COL));                 /* 열 입력을 반전한다(1은 키가 눌림을 의미)           */
}
#endif

/*$PAGE*/
/*
*********************************************************************************************************
*                                       멀티플렉싱 방식 LED 표시장치
*                                             I/O 포트 초기화
*
* 설명      : 이 함수는 LED멀티플렉싱에서 사용하는 출력포트를 초기화 하기 위해 DispInit()에 의해 호출된다
* 전달인자  : 없음
* 리턴값    : 없음
* 노트      : 74HC573  8비트 래치가 세그먼트와 숫자출력에 사용된다
*********************************************************************************************************
*/

#if  MODULE_LED
void  DispInitPort (void)
{
    outp(DISP_PORT_SEG, 0x00);              /* 세그먼트를 OFF한다                                      */
    outp(DISP_PORT_DIG, 0x00);              /* 숫자를 OFF한다                                          */
}

/*
*********************************************************************************************************
*                                     멀티플렉싱 방식 LED 표시장치
*                                             세그먼트 출력
*
* 설명      : 이 함수는 7-세그먼트 패턴을 출력한다
* 전달인자  : seg ; 출력하고자 하는 7-세그먼트 패턴
* 리턴값    : 없음
*********************************************************************************************************
*/

void  DispOutSeg (INT8U seg)
{
    outp(DISP_PORT_SEG, seg);
}

/*
*********************************************************************************************************
*                                     멀티플렉싱 방식 LED 표시장치
*                                              숫자 출력
*
* 설명      : 이 함수는 숫자 셀렉터를 출력한다.
* 전달인자  : msk ; 현재의 숫자를 선택하기 위해 사용되는 마스크.
* 리턴값    : 없음
*********************************************************************************************************
*/

void  DispOutDig (INT8U msk)
{
    outp(DISP_PORT_DIG, msk);
}
#endif

/*$PAGE*/
/*
*********************************************************************************************************
*                                              LCD 표시 모듈
*                                    디스플레이 드라이버의 I/O포트 초기화
*
* 설명      : 이 함수는 디스플레이 드라이버에서 사용하는 I/O포트를 초기화 한다.
* 전달인자  : 없음
* 리턴값    : 없음
*********************************************************************************************************
*/

#if  MODULE_LCD
void  DispInitPort (void)
{
    outp(DISP_PORT_CMD, 0x82);         /* 모드 0으로 설정: A;출력, B;입력, C;출력                      */
}

/*
*********************************************************************************************************
*                                              LCD 표시 모듈
*                                          표시장치에 데이터 쓰기
*
* 설명      : 이 함수는 표시장치로 1바이트 데이터를 전송한다.
* 전달인자  : 'data' 표시장치로 전송하고자 하는 데이터
* 리턴값    : 없음
* 노트      : 여러 분은 데이터 쓰기 사이에 필요한 최소한 40uS의 딜레이를 만들기 위해서
*             DISP_DLY_CNTS (LCD.H)의 값을 조절해야 한다. 필자가 시험에 사용한 장치는 실제로 
*             80uS가 필요했다! 만약 스크린 상의 문자가 무작위로 표시된다면 DISP_DLY_CNTS의 값을
*             증가시켜야 한다.
*********************************************************************************************************
*/
void  DispDataWr (INT8U data)
{
    INT8U  dly;


    outp(DISP_PORT_DATA, data);                  /* 표시모듈에 데이터를 쓴다                           */
    outp(DISP_PORT_CMD,  0x01);                  /* E라인을 HIGH로 세트한다                            */
    DispDummy();                                 /* 1 uS 정도 지연한다                                 */
    outp(DISP_PORT_CMD,  0x00);                  /* E라인을 LOW로 세트한다                             */
    for (dly = DISP_DLY_CNTS; dly > 0; dly--) {  /* 최소한 40 uS정도 지연한다                          */
        DispDummy();
    }
}

/*
*********************************************************************************************************
*                                              LCD 표시 모듈
*                                     명령어 또는 데이터 레지스터 선택
*
* 설명      : 이 함수는 표시장치의 레지스터를 선택할 때 사용된다.
* 전달인자  : 없음
*********************************************************************************************************
*/
void  DispSel (INT8U sel)
{
    if (sel == DISP_SEL_CMD_REG) {
        outp(DISP_PORT_CMD, 0x02);     /* 명령어 레지스터를 선택(RS low)                               */
    } else {
        outp(DISP_PORT_CMD, 0x03);     /* 데이터 레지스터를 선택(RS high)                              */
    }
}
#endif

/*$PAGE*/
/*
*********************************************************************************************************
*                                            시계/달력 모듈
*********************************************************************************************************
*/

#if MODULE_CLK
#endif

/*
*********************************************************************************************************
*                                             타이머 관리자
*********************************************************************************************************
*/

#if MODULE_TMR
#endif

/*$PAGE*/
/*
*********************************************************************************************************
*                                            디지털 I/O 모듈
*                                          물리적인 I/O 초기화
*
* 설명      : 이 함수는 DIO드라이에 사용되는 I/O 포트 초기화를 위해 DIOInit()에 의해서 호출된다
* 전달인자  : 없음.
* 리턴값    : 없음.
* 노트      : I/O는 다음과 같이 초기화된 82C55A 칩으로 가정했다.
*                 포트 A = 출력 (Discrete outputs)   (Address 0x0300)
*                 포트 B = 입력 (Discrete inputs)    (Address 0x0301)
*                 포트 C = 출력 (not used)           (Address 0x0302)
*                 컨트롤 워드                        (Address 0x0303)
*             Intel 82C55A 데이터 시트를 참조하라.
*********************************************************************************************************
*/

#if  MODULE_DIO
void  DIOInitIO (void)
{
    outp(0x0303, 0x82);                          /* 포트 A = 출력, 포트 B = 입력, 포트 C = 출력        */
}

/*
*********************************************************************************************************
*                                            디지털 I/O 모듈
*                                               입력 읽기
*
* 설명      : 이 함수는 디지털 입력에 사용되는 물리적인 입력을 모두 읽고 매핑하기 위해 호출된다.
*             또한 이 입력은 대응되는 입력 데이터 스트럭처에 매핑된다.
* 전달인자  : 없음.
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  DIRd (void)
{
    DIO_DI *pdi;
    INT8U   i;
    INT8U   in;
    INT8U   msk;


    pdi = &DITbl[0];                                       /* 디지털입력 구조체의 시작을 포인트 한다   */
    msk = 0x01;                                            /* 비트 0을 빼내기 위해 마스크를 세트한다   */
    in  = inp(0x0301);                                     /* 물리적 포트를 읽는다(8 비트)             */
    for (i = 0; i < 8; i++) {                              /* 8비트를 처음 8개의 디지털입력 채널에 세트*/
        pdi->DIIn   = (BOOLEAN)(in & msk) ? 1 : 0;
        msk       <<= 1;
        pdi++;
    }
}

/*
*********************************************************************************************************
*                                            디지털 I/O 모듈
*                                         물리적 출력포트 갱신
*
* 설명      : 이 함수는 모든 디지털출력 채널을 대응되는 물리적 포트로 매핑하기 위해 호출된다.
*
* 전달인자  : 없음.
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  DOWr (void)
{
    DIO_DO *pdo;
    INT8U   i;
    INT8U   out;
    INT8U   msk;


    pdo = &DOTbl[0];                        /* 디지털출력 구조체의 시작을 포인트 한다                  */
    msk = 0x01;                             /* 최초의 디지털출력은 비트 0으로 매핑된다                 */
    out = 0x00;                             /* 8비트 포트 이미지를 초기화 한다                         */
    for (i = 0; i < 8; i++) {               /* 처음 8개의 디지털출력을 포트 이미지로 매핑              */
        if (pdo->DOOut == TRUE) {
            out |= msk;
        }
        msk <<= 1;
        pdo++;
    }
    outp(0x0300, out);                      /* 완성된 포트 이미지를 물리적 포트로 출력                 */
}
#endif

/*$PAGE*/
/*
*********************************************************************************************************
*                                           아날로그 I/O 모듈
*                                           물리적 I/O 초기화
*
* 설명      : 이 함수는 AIO 드라이버에서 사용하는 물리적 I/O를 초기화 하기 위해 AIOInit()에 의해서
*             호출된다
* 전달인자  : 없음.
* 리턴값    : 없음.
*********************************************************************************************************
*/

#if  MODULE_AIO
void  AIOInitIO (void)
{
    /* 이 곳에 실제로 ADC 와 DAC를 초기화 하는 코드를 삽입해야 한다.                                   */
    /* 또한 DAC를 알려진 값으로 초기화 하는 것을 고려해야 한다.                                        */
    
    AITestCnts = 0;
}

/*
*********************************************************************************************************
*                                           아날로그 I/O 모듈
*                                            물리적 입력 읽기
*
* 설명      : 이 함수는 물리적인 ADC 채널의 값을 읽기 위해 호출된다. 또한 하나 이상의 채널이 ADC에
*             연결되어 있다면 멀티플렉서를 제어하는 코드로 이곳에 구현돼야 한다.
* 전달인자  : ch ; ADC의 논리적 채널 번호 (0..AIO_MAX_AI-1).
* 리턴값    : 실제 장치에서의 ADC 값.
*********************************************************************************************************
*/

INT16S  AIRd (INT8U ch)
{
    /* 이 곳에 실제 ADC로부터 값을 읽기위한 코드가 추가돼야 한다.                                      */
    /* AIRd() 로는 논리적인 채널 번호가 넘어 온다. 여러분은 이 논리적인 채널을 MUX와 ADC가 위치한      */
    /* 실제 물리적인 포트 위치(또는 주소)로 변환해야 한다.                                             */
    /* AIRd() 는 다음 일을 수행한다                                                                    */
    /*     1) 적절한 MUX 채널을 선택한다                                                               */
    /*     2) MUX가 안정화 될 때 까지 기다린다                                                         */
    /*     3) ADC를 시작한다                                                                           */
    /*     4) ADC가 컨버전을 완료할 때 까지 기다린다                                                   */
    /*     5) ADC의 결과를 읽는다                                                                      */
    /*     6) 호출한 함수로 그 값을 돌려준다                                                           */

                                       /* RAMPING 볼트 출력을 시뮬레이션 한다                          */
    AITestCnts += 10;                  /* ADC는 부호 있는 16비트 정수를 돌려준다고 가정한다.           */
    if (AITestCnts > 28670) {          /* LM34A가 300 F에서 2.5의 이득일 때 최대값                     */
        AITestCnts = 0;
    }
    return (AITestCnts);
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                           아날로그 I/O 모듈
*                                           물리적인 출력 갱신
*
* 설명      : 이 함수는 적절한 아날로그 출력 장치(DAC)로 원하는 값을 출력할 때 호출된다.
*             하나 이상의 DAC가 사용될 경우 올바른 채널로 값을 출력하는 것은 이 함수에 달려있다.
*
* 전달인자  : ch ; DAC의 논리적 채널 번호 (0..AIO_MAX_AO-1).
*             cnts ; 출력하고자 하는 DAC의 값.
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  AOWr (INT8U ch, INT16S cnts)
{
    ch   = ch;
    cnts = cnts;

    /* 이 곳은 DAC를 갱신하기 위한 코드가 삽입될 곳이다.                                               */
    /* AOWr() 로는 논리적 채널 번호가 넘어온다. 여러 분은 이 논리적인 채널을 DAC가 위치한              */
    /* 실제 물리적인 포트 위치(또는 주소)로 변환해야 한다.                                             */
    /* AOWr()은 논리적 번호에 의해 선택된 DAC로 원하는 값을 출력하는 일을 담당한다.                    */
}
#endif
